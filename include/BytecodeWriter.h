#pragma once

#include "DreamProcOpcode.h"
#include "DMReference.h"
#include "Location.h"
#include <vector>
#include <cstdint>
#include <string>
#include <unordered_map>
#include <optional>

namespace DMCompiler {

/// <summary>
/// Helper class for generating bytecode instructions for DM procedures.
/// Provides methods for emitting opcodes and their operands, managing labels and jumps.
/// </summary>
class BytecodeWriter {
public:
    BytecodeWriter();
    
    /// <summary>
    /// Emit a simple opcode with no operands.
    /// </summary>
    void Emit(DreamProcOpcode opcode);
    
    /// <summary>
    /// Emit an opcode with a single byte operand.
    /// </summary>
    void EmitByte(DreamProcOpcode opcode, uint8_t value);
    
    /// <summary>
    /// Emit an opcode with a 16-bit integer operand.
    /// </summary>
    void EmitShort(DreamProcOpcode opcode, uint16_t value);
    
    /// <summary>
    /// Emit an opcode with a 32-bit integer operand.
    /// </summary>
    void EmitInt(DreamProcOpcode opcode, int32_t value);
    
    /// <summary>
    /// Emit an opcode with a float operand.
    /// </summary>
    void EmitFloat(DreamProcOpcode opcode, float value);
    
    /// <summary>
    /// Emit an opcode with a string operand (stored as string table index).
    /// </summary>
    void EmitString(DreamProcOpcode opcode, const std::string& value);
    
    /// <summary>
    /// Emit an opcode with multiple operands.
    /// </summary>
    void EmitMulti(DreamProcOpcode opcode, const std::vector<uint8_t>& operands);
    
    /// <summary>
    /// Create a label at the current position.
    /// Labels are used as jump targets.
    /// </summary>
    /// <returns>Label identifier that can be used with EmitJump.</returns>
    int CreateLabel();
    
    /// <summary>
    /// Mark the current position with a label.
    /// </summary>
    void MarkLabel(int labelId);
    
    /// <summary>
    /// Emit a jump opcode that will be fixed up later when the label position is known.
    /// </summary>
    void EmitJump(DreamProcOpcode opcode, int labelId);
    
    /// <summary>
    /// Emit a jump opcode with reference bytes (for JumpIfTrueReference/JumpIfFalseReference).
    /// The reference bytes are emitted immediately after the opcode, followed by the jump offset.
    /// </summary>
    void EmitJumpWithReference(DreamProcOpcode opcode, const std::vector<uint8_t>& refBytes, int labelId);
    
    /// <summary>
    /// Finalize the bytecode by resolving all jump labels.
    /// Must be called before GetBytecode().
    /// </summary>
    void Finalize();
    
    /// <summary>
    /// Get the generated bytecode.
    /// </summary>
    const std::vector<uint8_t>& GetBytecode() const { return Bytecode_; }
    
    /// <summary>
    /// Get the current bytecode position.
    /// </summary>
    size_t GetPosition() const { return Bytecode_.size(); }
    
    /// <summary>
    /// Get the maximum stack size required by this proc.
    /// Tracks the peak stack depth during bytecode generation.
    /// </summary>
    int GetMaxStackSize() const { return MaxStackSize_; }
    
    /// <summary>
    /// Track stack size changes for an operation.
    /// </summary>
    void ResizeStack(int sizeDelta);
    
    /// <summary>
    /// Get or create a string table index for a string constant.
    /// </summary>
    int GetStringId(const std::string& str);
    
    /// <summary>
    /// Reset the writer for generating new bytecode.
    /// </summary>
    void Reset();
    
    /// <summary>
    /// Append a raw byte to the bytecode (for use after EmitString, etc.)
    /// </summary>
    void AppendByte(uint8_t value);
    
    /// <summary>
    /// Append a raw 32-bit int to the bytecode (for use after EmitString, etc.)
    /// </summary>
    void AppendInt(int32_t value);
    
    /// <summary>
    /// Emit a DMReference for a global proc (type byte + proc ID)
    /// Used with Call opcode for global procedure calls
    /// </summary>
    /// <param name="procId">The ID of the global proc to reference</param>
    void EmitGlobalProcReference(int procId);
    
    /// <summary>
    /// Write a DMReference to the bytecode.
    /// Writes the reference type byte followed by any additional data (index, string ID, etc.)
    /// </summary>
    /// <param name="reference">The reference to write</param>
    void WriteReference(const DMReference& reference);
    
    /// <summary>
    /// Create a list enumerator for for-in loops.
    /// Expects the list to be on the stack.
    /// </summary>
    /// <param name="enumeratorId">Unique ID for this enumerator</param>
    void CreateListEnumerator(int enumeratorId);
    
    /// <summary>
    /// Create a filtered list enumerator for for-in loops with type filtering.
    /// Expects the list to be on the stack.
    /// </summary>
    /// <param name="enumeratorId">Unique ID for this enumerator</param>
    /// <param name="filterTypeId">Type ID to filter by</param>
    /// <param name="filterPath">DreamPath string for the filter type</param>
    void CreateFilteredListEnumerator(int enumeratorId, int filterTypeId, const std::string& filterPath);
    
    /// <summary>
    /// Enumerate next value from enumerator into a reference.
    /// Jumps to endLabel when enumeration is complete.
    /// </summary>
    /// <param name="enumeratorId">The enumerator to use</param>
    /// <param name="reference">Where to store the enumerated value</param>
    /// <param name="endLabel">Label to jump to when enumeration is done</param>
    void Enumerate(int enumeratorId, const DMReference& reference, int endLabel);
    
    /// <summary>
    /// Enumerate next key/value pair from associative list.
    /// Jumps to endLabel when enumeration is complete.
    /// </summary>
    /// <param name="enumeratorId">The enumerator to use</param>
    /// <param name="assocRef">Where to store the key</param>
    /// <param name="outputRef">Where to store the value</param>
    /// <param name="endLabel">Label to jump to when enumeration is done</param>
    void EnumerateAssoc(int enumeratorId, const DMReference& assocRef, const DMReference& outputRef, int endLabel);
    
    /// <summary>
    /// Enumerate without assignment (used for short-circuit cases).
    /// Jumps to endLabel when enumeration is complete.
    /// </summary>
    /// <param name="enumeratorId">The enumerator to use</param>
    /// <param name="endLabel">Label to jump to when enumeration is done</param>
    void EnumerateNoAssign(int enumeratorId, int endLabel);
    
    /// <summary>
    /// Destroy an enumerator and free its resources.
    /// </summary>
    /// <param name="enumeratorId">The enumerator to destroy</param>
    void DestroyEnumerator(int enumeratorId);

private:
    /// <summary>
    /// The generated bytecode stream.
    /// </summary>
    std::vector<uint8_t> Bytecode_;
    
    /// <summary>
    /// String constant table.
    /// Maps strings to their indices for bytecode references.
    /// </summary>
    std::unordered_map<std::string, int> StringTable_;
    std::vector<std::string> Strings_;
    
    /// <summary>
    /// Label tracking for jump instructions.
    /// Maps label IDs to bytecode positions.
    /// </summary>
    std::unordered_map<int, size_t> LabelPositions_;
    
    /// <summary>
    /// Pending jump fixups.
    /// Stores positions in bytecode where jump offsets need to be filled in.
    /// </summary>
    struct PendingJump {
        size_t BytecodePosition;  // Where the jump offset is stored
        int TargetLabel;          // Which label this jump targets
        DreamProcOpcode Opcode;   // The jump opcode (for debugging)
    };
    std::vector<PendingJump> PendingJumps_;
    
    /// <summary>
    /// Next label ID to assign.
    /// </summary>
    int NextLabelId_;
    
    /// <summary>
    /// Current stack depth (for tracking max stack size).
    /// </summary>
    int CurrentStackSize_;
    
    /// <summary>
    /// Maximum stack depth reached during bytecode generation.
    /// </summary>
    int MaxStackSize_;
    
    /// <summary>
    /// Write a byte to the bytecode stream.
    /// </summary>
    void WriteByte(uint8_t value);
    
    /// <summary>
    /// Write a 16-bit value in little-endian format.
    /// </summary>
    void WriteShort(uint16_t value);
    
    /// <summary>
    /// Write a 32-bit value in little-endian format.
    /// </summary>
    void WriteInt(int32_t value);
    
    /// <summary>
    /// Write a float in IEEE 754 format.
    /// </summary>
    void WriteFloat(float value);
};

} // namespace DMCompiler
